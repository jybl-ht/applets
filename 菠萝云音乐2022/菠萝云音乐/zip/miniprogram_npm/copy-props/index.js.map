{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nvar eachProps = require('each-props');\nvar isPlainObject = require('is-plain-object').isPlainObject;\n\nmodule.exports = function(src, dst, fromto, converter, reverse) {\n\n  if (!isObject(src)) {\n    src = {};\n  }\n\n  if (!isObject(dst)) {\n    dst = {};\n  }\n\n  if (isPlainObject(fromto)) {\n    fromto = onlyValueIsString(fromto);\n  } else if (Array.isArray(fromto)) {\n    fromto = arrayToObject(fromto);\n  } else if (typeof fromto === 'boolean') {\n    reverse = fromto;\n    converter = noop;\n    fromto = null;\n  } else if (typeof fromto === 'function') {\n    reverse = converter;\n    converter = fromto;\n    fromto = null;\n  } else {\n    fromto = null;\n  }\n\n  if (typeof converter !== 'function') {\n    if (typeof converter === 'boolean') {\n      reverse = converter;\n      converter = noop;\n    } else {\n      converter = noop;\n    }\n  }\n\n  if (typeof reverse !== 'boolean') {\n    reverse = false;\n  }\n\n  if (reverse) {\n    var tmp = src;\n    src = dst;\n    dst = tmp;\n\n    if (fromto) {\n      fromto = invert(fromto);\n    }\n  }\n\n  var opts = {\n    dest: dst,\n    fromto: fromto,\n    convert: converter,\n  };\n\n  if (fromto) {\n    eachProps(src, copyWithFromto, opts);\n    setParentEmptyObject(dst, fromto);\n  } else {\n    eachProps(src, copyWithoutFromto, opts);\n  }\n\n  return dst;\n};\n\nfunction copyWithFromto(value, keyChain, nodeInfo) {\n  if (isPlainObject(value)) {\n    return;\n  }\n\n  var dstKeyChains = nodeInfo.fromto[keyChain];\n  if (!dstKeyChains) {\n    return;\n  }\n  delete nodeInfo.fromto[keyChain];\n\n  if (!Array.isArray(dstKeyChains)) {\n    dstKeyChains = [dstKeyChains];\n  }\n\n  var srcInfo = {\n    keyChain: keyChain,\n    value: value,\n    key: nodeInfo.name,\n    depth: nodeInfo.depth,\n    parent: nodeInfo.parent,\n  };\n\n  for (var i = 0, n = dstKeyChains.length; i < n; i++) {\n    setDeep(nodeInfo.dest, dstKeyChains[i], function(parent, key, depth) {\n      var dstInfo = {\n        keyChain: dstKeyChains[i],\n        value: parent[key],\n        key: key,\n        depth: depth,\n        parent: parent,\n      };\n\n      return nodeInfo.convert(srcInfo, dstInfo);\n    });\n  }\n}\n\nfunction copyWithoutFromto(value, keyChain, nodeInfo) {\n  if (isPlainObject(value)) {\n    for (var k in value) {\n      return;\n    }\n    setDeep(nodeInfo.dest, keyChain, newObject);\n    return;\n  }\n\n  var srcInfo = {\n    keyChain: keyChain,\n    value: value,\n    key: nodeInfo.name,\n    depth: nodeInfo.depth,\n    parent: nodeInfo.parent,\n  };\n\n  setDeep(nodeInfo.dest, keyChain, function(parent, key, depth) {\n    var dstInfo = {\n      keyChain: keyChain,\n      value: parent[key],\n      key: key,\n      depth: depth,\n      parent: parent,\n    };\n\n    return nodeInfo.convert(srcInfo, dstInfo);\n  });\n}\n\nfunction newObject() {\n  return {};\n}\n\nfunction noop(srcInfo) {\n  return srcInfo.value;\n}\n\nfunction onlyValueIsString(obj) {\n  var newObj = {};\n  for (var key in obj) {\n    var val = obj[key];\n    if (typeof val === 'string') {\n      newObj[key] = val;\n    }\n  }\n  return newObj;\n}\n\nfunction arrayToObject(arr) {\n  var obj = {};\n  for (var i = 0, n = arr.length; i < n; i++) {\n    var elm = arr[i];\n    if (typeof elm === 'string') {\n      obj[elm] = elm;\n    }\n  }\n  return obj;\n}\n\nfunction invert(fromto) {\n  var inv = {};\n  for (var key in fromto) {\n    var val = fromto[key];\n    if (!inv[val]) {\n      inv[val] = [];\n    }\n    inv[val].push(key);\n  }\n  return inv;\n}\n\nfunction setDeep(obj, keyChain, valueCreator) {\n  _setDeep(obj, keyChain.split('.'), 1, valueCreator);\n}\n\nfunction _setDeep(obj, keyElems, depth, valueCreator) {\n  var key = keyElems.shift();\n  if (isPossibilityOfPrototypePollution(key)) {\n    return;\n  }\n\n  if (!keyElems.length) {\n    var value = valueCreator(obj, key, depth);\n    if (value === undefined) {\n      return;\n    }\n    if (isPlainObject(value)) { // value is always an empty object.\n      if (isPlainObject(obj[key])) {\n        return;\n      }\n    }\n    obj[key] = value;\n    return;\n  }\n\n  if (!isPlainObject(obj[key])) {\n    obj[key] = {};\n  }\n  _setDeep(obj[key], keyElems, depth + 1, valueCreator);\n}\n\nfunction setParentEmptyObject(obj, fromto) {\n  for (var srcKeyChain in fromto) {\n    var dstKeyChains = fromto[srcKeyChain];\n    if (!Array.isArray(dstKeyChains)) {\n      dstKeyChains = [dstKeyChains];\n    }\n\n    for (var i = 0, n = dstKeyChains.length; i < n; i++) {\n      setDeep(obj, dstKeyChains[i], newUndefined);\n    }\n  }\n}\n\nfunction newUndefined() {\n  return undefined;\n}\n\nfunction isObject(v) {\n  return Object.prototype.toString.call(v) === '[object Object]';\n}\n\nfunction isPossibilityOfPrototypePollution(key) {\n  return (key === '__proto__' || key === 'constructor');\n}\n"]}