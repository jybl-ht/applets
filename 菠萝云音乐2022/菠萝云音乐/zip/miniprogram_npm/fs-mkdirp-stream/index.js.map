{"version":3,"sources":["index.js","mkdirp.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nvar through = require('through2');\n\nvar mkdirp = require('./mkdirp');\n\nfunction toFunction(dirpath) {\n  function stringResolver(chunk, callback) {\n    callback(null, dirpath);\n  }\n\n  return stringResolver;\n}\n\nfunction define(options) {\n\n  function mkdirpStream(resolver) {\n    // Handle resolver that's just a dirpath\n    if (typeof resolver === 'string') {\n      resolver = toFunction(resolver);\n    }\n\n    function makeFileDirs(chunk, enc, callback) {\n      resolver(chunk, onDirpath);\n\n      function onDirpath(dirpathErr, dirpath, mode) {\n        if (dirpathErr) {\n          return callback(dirpathErr);\n        }\n\n        mkdirp(dirpath, mode, onMkdirp);\n      }\n\n      function onMkdirp(mkdirpErr) {\n        if (mkdirpErr) {\n          return callback(mkdirpErr);\n        }\n\n        callback(null, chunk);\n      }\n    }\n\n    return through(options, makeFileDirs);\n  }\n\n  return mkdirpStream;\n}\n\nmodule.exports = define();\nmodule.exports.obj = define({ objectMode: true, highWaterMark: 16 });\n","\n\nvar path = require('path');\n\nvar fs = require('graceful-fs');\n\nvar MASK_MODE = parseInt('7777', 8);\nvar DEFAULT_DIR_MODE = parseInt('0777', 8);\n\nfunction mkdirp(dirpath, customMode, callback) {\n  if (typeof customMode === 'function') {\n    callback = customMode;\n    customMode = undefined;\n  }\n\n  var mode = customMode || (DEFAULT_DIR_MODE & ~process.umask());\n  dirpath = path.resolve(dirpath);\n\n  fs.mkdir(dirpath, mode, onMkdir);\n\n  function onMkdir(mkdirErr) {\n    if (!mkdirErr) {\n      return fs.stat(dirpath, onStat);\n    }\n\n    switch (mkdirErr.code) {\n      case 'ENOENT': {\n        return mkdirp(path.dirname(dirpath), onRecurse);\n      }\n\n      case 'EEXIST': {\n        return fs.stat(dirpath, onStat);\n      }\n\n      default: {\n        return callback(mkdirErr);\n      }\n    }\n\n    function onStat(statErr, stats) {\n      if (statErr) {\n        return callback(statErr);\n      }\n\n      if (!stats.isDirectory()) {\n        return callback(mkdirErr);\n      }\n\n      // TODO: Is it proper to mask like this?\n      if ((stats.mode & MASK_MODE) === mode) {\n        return callback();\n      }\n\n      if (!customMode) {\n        return callback();\n      }\n\n      fs.chmod(dirpath, mode, callback);\n    }\n  }\n\n  function onRecurse(recurseErr) {\n    if (recurseErr) {\n      return callback(recurseErr);\n    }\n\n    mkdirp(dirpath, mode, callback);\n  }\n}\n\nmodule.exports = mkdirp;\n"]}