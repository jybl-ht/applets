{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\n/**\n * Module dependencies\n */\n\nvar fs = require('fs');\nvar path = require('path');\nvar isGlob = require('is-glob');\nvar resolveDir = require('resolve-dir');\nvar detect = require('detect-file');\nvar mm = require('micromatch');\n\n/**\n * @param  {String|Array} `pattern` Glob pattern or file path(s) to match against.\n * @param  {Object} `options` Options to pass to [micromatch]. Note that if you want to start in a different directory than the current working directory, specify the `options.cwd` property here.\n * @return {String} Returns the first matching file.\n * @api public\n */\n\nmodule.exports = function(patterns, options) {\n  options = options || {};\n  var cwd = path.resolve(resolveDir(options.cwd || ''));\n\n  if (typeof patterns === 'string') {\n    return lookup(cwd, [patterns], options);\n  }\n\n  if (!Array.isArray(patterns)) {\n    throw new TypeError('findup-sync expects a string or array as the first argument.');\n  }\n\n  return lookup(cwd, patterns, options);\n};\n\nfunction lookup(cwd, patterns, options) {\n  var len = patterns.length;\n  var idx = -1;\n  var res;\n\n  while (++idx < len) {\n    if (isGlob(patterns[idx])) {\n      res = matchFile(cwd, patterns[idx], options);\n    } else {\n      res = findFile(cwd, patterns[idx], options);\n    }\n    if (res) {\n      return res;\n    }\n  }\n\n  var dir = path.dirname(cwd);\n  if (dir === cwd) {\n    return null;\n  }\n  return lookup(dir, patterns, options);\n}\n\nfunction matchFile(cwd, pattern, opts) {\n  var isMatch = mm.matcher(pattern, opts);\n  var files = tryReaddirSync(cwd);\n  var len = files.length;\n  var idx = -1;\n\n  while (++idx < len) {\n    var name = files[idx];\n    var fp = path.join(cwd, name);\n    if (isMatch(name) || isMatch(fp)) {\n      return fp;\n    }\n  }\n  return null;\n}\n\nfunction findFile(cwd, filename, options) {\n  var fp = cwd ? path.resolve(cwd, filename) : filename;\n  return detect(fp, options);\n}\n\nfunction tryReaddirSync(fp) {\n  try {\n    return fs.readdirSync(fp);\n  } catch (err) {\n    // Ignore error\n  }\n  return [];\n}\n"]}