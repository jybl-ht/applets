{"version":3,"sources":["index.js","lib/find_cwd.js","lib/find_config.js","lib/file_search.js","lib/parse_options.js","lib/silent_require.js","lib/build_config_name.js","lib/register_loader.js","lib/get_node_flags.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AGTA,ADGA,ADGA;ADIA,AGTA,ADGA,ADGA;ADIA,AGTA,ADGA,ADGA;ADIA,AGTA,ADGA,ADGA,AGTA;AJaA,AGTA,ADGA,ADGA,AGTA;AJaA,AGTA,ADGA,ADGA,AGTA;AJaA,AGTA,ADGA,ADGA,AGTA,ACHA;ALgBA,AGTA,ADGA,ADGA,AGTA,ACHA;ALgBA,AGTA,ADGA,ADGA,AGTA,ACHA;ALgBA,AMlBA,AHSA,ADGA,ADGA,AGTA,ACHA;ALgBA,AMlBA,AHSA,ADGA,ADGA,AGTA,ACHA;ALgBA,AMlBA,AHSA,ADGA,ADGA,AGTA,ACHA;ALgBA,AMlBA,AHSA,ADGA,ADGA,AGTA,AGTA;APsBA,AMlBA,AHSA,ADGA,AENA,AGTA;APsBA,AMlBA,AHSA,ADGA,AENA,AGTA;APsBA,AMlBA,AJYA,AMlBA,AJYA,AGTA;APsBA,AMlBA,AJYA,AMlBA,AJYA,AGTA;APsBA,AMlBA,AJYA,AMlBA,AJYA,AGTA;APsBA,AMlBA,AJYA,AMlBA,AJYA,AGTA;APsBA,AMlBA,AJYA,AMlBA,AJYA,AGTA;APsBA,AMlBA,AJYA,AMlBA,AJYA,AGTA;APsBA,AMlBA,AJYA,AMlBA,AJYA,AGTA;APsBA,AMlBA,AJYA,AMlBA,AJYA,AGTA;APsBA,AMlBA,AENA,AJYA,AGTA;APsBA,AMlBA,AENA,AJYA,AGTA;APsBA,AMlBA,AENA,AJYA,AGTA;APsBA,AMlBA,AENA,AJYA,AGTA;APsBA,AQxBA,AJYA,AGTA;APsBA,AQxBA,AJYA,AGTA;APsBA,AQxBA,AJYA,AGTA;APsBA,AQxBA,AJYA,AGTA;APsBA,AQxBA,AJYA,AGTA;APsBA,AQxBA,AJYA,AGTA;APsBA,AQxBA,AJYA,AGTA;APsBA,AQxBA,AJYA,AGTA;APsBA,AQxBA,AJYA,AGTA;APsBA,AQxBA,AJYA,AGTA;APsBA,AQxBA,AJYA;AJaA,AQxBA,AJYA;AJaA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var util = require('util');\nvar path = require('path');\nvar EE = require('events').EventEmitter;\n\nvar extend = require('extend');\nvar resolve = require('resolve');\nvar flaggedRespawn = require('flagged-respawn');\nvar isPlainObject = require('is-plain-object');\nvar mapValues = require('object.map');\nvar fined = require('fined');\n\nvar findCwd = require('./lib/find_cwd');\nvar findConfig = require('./lib/find_config');\nvar fileSearch = require('./lib/file_search');\nvar parseOptions = require('./lib/parse_options');\nvar silentRequire = require('./lib/silent_require');\nvar buildConfigName = require('./lib/build_config_name');\nvar registerLoader = require('./lib/register_loader');\nvar getNodeFlags = require('./lib/get_node_flags');\n\nfunction Liftoff(opts) {\n  EE.call(this);\n  extend(this, parseOptions(opts));\n}\nutil.inherits(Liftoff, EE);\n\nLiftoff.prototype.requireLocal = function(module, basedir) {\n  try {\n    var result = require(resolve.sync(module, { basedir: basedir }));\n    this.emit('require', module, result);\n    return result;\n  } catch (e) {\n    this.emit('requireFail', module, e);\n  }\n};\n\nLiftoff.prototype.buildEnvironment = function(opts) {\n  opts = opts || {};\n\n  // get modules we want to preload\n  var preload = opts.require || [];\n\n  // ensure items to preload is an array\n  if (!Array.isArray(preload)) {\n    preload = [preload];\n  }\n\n  // make a copy of search paths that can be mutated for this run\n  var searchPaths = this.searchPaths.slice();\n\n  // calculate current cwd\n  var cwd = findCwd(opts);\n\n  // if cwd was provided explicitly, only use it for searching config\n  if (opts.cwd) {\n    searchPaths = [cwd];\n  } else {\n    // otherwise just search in cwd first\n    searchPaths.unshift(cwd);\n  }\n\n  // calculate the regex to use for finding the config file\n  var configNameSearch = buildConfigName({\n    configName: this.configName,\n    extensions: Object.keys(this.extensions),\n  });\n\n  // calculate configPath\n  var configPath = findConfig({\n    configNameSearch: configNameSearch,\n    searchPaths: searchPaths,\n    configPath: opts.configPath,\n  });\n\n  // if we have a config path, save the directory it resides in.\n  var configBase;\n  if (configPath) {\n    configBase = path.dirname(configPath);\n    // if cwd wasn't provided explicitly, it should match configBase\n    if (!opts.cwd) {\n      cwd = configBase;\n    }\n  }\n\n  // TODO: break this out into lib/\n  // locate local module and package next to config or explicitly provided cwd\n  /* eslint one-var: 0 */\n  var modulePath, modulePackage;\n  try {\n    var delim = path.delimiter;\n    var paths = (process.env.NODE_PATH ? process.env.NODE_PATH.split(delim) : []);\n    modulePath = resolve.sync(this.moduleName, { basedir: configBase || cwd, paths: paths });\n    modulePackage = silentRequire(fileSearch('package.json', [modulePath]));\n  } catch (e) {}\n\n  // if we have a configuration but we failed to find a local module, maybe\n  // we are developing against ourselves?\n  if (!modulePath && configPath) {\n    // check the package.json sibling to our config to see if its `name`\n    // matches the module we're looking for\n    var modulePackagePath = fileSearch('package.json', [configBase]);\n    modulePackage = silentRequire(modulePackagePath);\n    if (modulePackage && modulePackage.name === this.moduleName) {\n      // if it does, our module path is `main` inside package.json\n      modulePath = path.join(path.dirname(modulePackagePath), modulePackage.main || 'index.js');\n      cwd = configBase;\n    } else {\n      // clear if we just required a package for some other project\n      modulePackage = {};\n    }\n  }\n\n  var exts = this.extensions;\n  var eventEmitter = this;\n\n  var configFiles = {};\n  if (isPlainObject(this.configFiles)) {\n    var notfound = { path: null };\n    configFiles = mapValues(this.configFiles, function(prop, name) {\n      var defaultObj = { name: name, cwd: cwd, extensions: exts };\n      return mapValues(prop, function(pathObj) {\n        var found = fined(pathObj, defaultObj) || notfound;\n        if (isPlainObject(found.extension)) {\n          registerLoader(eventEmitter, found.extension, found.path, cwd);\n        }\n        return found.path;\n      });\n    });\n  }\n\n  return {\n    cwd: cwd,\n    require: preload,\n    configNameSearch: configNameSearch,\n    configPath: configPath,\n    configBase: configBase,\n    modulePath: modulePath,\n    modulePackage: modulePackage || {},\n    configFiles: configFiles,\n  };\n};\n\nLiftoff.prototype.handleFlags = function(cb) {\n  if (typeof this.v8flags === 'function') {\n    this.v8flags(function(err, flags) {\n      if (err) {\n        cb(err);\n      } else {\n        cb(null, flags);\n      }\n    });\n  } else {\n    process.nextTick(function() {\n      cb(null, this.v8flags);\n    }.bind(this));\n  }\n};\n\nLiftoff.prototype.prepare = function(opts, fn) {\n  if (typeof fn !== 'function') {\n    throw new Error('You must provide a callback function.');\n  }\n\n  process.title = this.processTitle;\n\n  var completion = opts.completion;\n  if (completion && this.completions) {\n    return this.completions(completion);\n  }\n\n  var env = this.buildEnvironment(opts);\n\n  fn.call(this, env);\n};\n\nLiftoff.prototype.execute = function(env, forcedFlags, fn) {\n  if (typeof forcedFlags === 'function') {\n    fn = forcedFlags;\n    forcedFlags = undefined;\n  }\n  if (typeof fn !== 'function') {\n    throw new Error('You must provide a callback function.');\n  }\n\n  this.handleFlags(function(err, flags) {\n    if (err) {\n      throw err;\n    }\n    flags = flags || [];\n\n    flaggedRespawn(flags, process.argv, forcedFlags, execute.bind(this));\n\n    function execute(ready, child, argv) {\n      if (child !== process) {\n        var execArgv = getNodeFlags.fromReorderedArgv(argv);\n        this.emit('respawn', execArgv, child);\n      }\n      if (ready) {\n        preloadModules(this, env);\n        registerLoader(this, this.extensions, env.configPath, env.cwd);\n        fn.call(this, env, argv);\n      }\n    }\n  }.bind(this));\n};\n\nLiftoff.prototype.launch = function(opts, fn) {\n  if (typeof fn !== 'function') {\n    throw new Error('You must provide a callback function.');\n  }\n\n  var self = this;\n\n  self.prepare(opts, function(env) {\n    var forcedFlags = getNodeFlags.arrayOrFunction(opts.forcedFlags, env);\n    self.execute(env, forcedFlags, fn);\n  });\n};\n\nfunction preloadModules(inst, env) {\n  var basedir = env.cwd;\n  env.require.filter(toUnique).forEach(function(module) {\n    inst.requireLocal(module, basedir);\n  });\n}\n\nfunction toUnique(elem, index, array) {\n  return array.indexOf(elem) === index;\n}\n\nmodule.exports = Liftoff;\n","var path = require('path');\n\nmodule.exports = function(opts) {\n  if (!opts) {\n    opts = {};\n  }\n  var cwd = opts.cwd;\n  var configPath = opts.configPath;\n  // if a path to the desired config was specified\n  // but no cwd was provided, use configPath dir\n  if (typeof configPath === 'string' && !cwd) {\n    cwd = path.dirname(path.resolve(configPath));\n  }\n  if (typeof cwd === 'string') {\n    return path.resolve(cwd);\n  }\n  return process.cwd();\n};\n","var fs = require('fs');\nvar path = require('path');\nvar fileSearch = require('./file_search');\n\nmodule.exports = function(opts) {\n  opts = opts || {};\n  var configNameSearch = opts.configNameSearch;\n  var configPath = opts.configPath;\n  var searchPaths = opts.searchPaths;\n  // only search for a config if a path to one wasn't explicitly provided\n  if (!configPath) {\n    if (!Array.isArray(searchPaths)) {\n      throw new Error('Please provide an array of paths to search for config in.');\n    }\n    if (!configNameSearch) {\n      throw new Error('Please provide a configNameSearch.');\n    }\n    configPath = fileSearch(configNameSearch, searchPaths);\n  }\n  // confirm the configPath exists and return an absolute path to it\n  if (fs.existsSync(configPath)) {\n    return path.resolve(configPath);\n  }\n  return null;\n};\n","var findup = require('findup-sync');\n\nmodule.exports = function(search, paths) {\n  var path;\n  var len = paths.length;\n  for (var i = 0; i < len; i++) {\n    if (path) {\n      break;\n    } else {\n      path = findup(search, { cwd: paths[i], nocase: true });\n    }\n  }\n  return path;\n};\n","var extend = require('extend');\n\nmodule.exports = function(opts) {\n  var defaults = {\n    extensions: {\n      '.js': null,\n      '.json': null,\n    },\n    searchPaths: [],\n  };\n  if (!opts) {\n    opts = {};\n  }\n  if (opts.name) {\n    if (!opts.processTitle) {\n      opts.processTitle = opts.name;\n    }\n    if (!opts.configName) {\n      opts.configName = opts.name + 'file';\n    }\n    if (!opts.moduleName) {\n      opts.moduleName = opts.name;\n    }\n  }\n  if (!opts.processTitle) {\n    throw new Error('You must specify a processTitle.');\n  }\n  if (!opts.configName) {\n    throw new Error('You must specify a configName.');\n  }\n  if (!opts.moduleName) {\n    throw new Error('You must specify a moduleName.');\n  }\n  return extend(defaults, opts);\n};\n","module.exports = function(path) {\n  try {\n    return require(path);\n  } catch (e) {}\n};\n","module.exports = function(opts) {\n  opts = opts || {};\n  var configName = opts.configName;\n  var extensions = opts.extensions;\n  if (!configName) {\n    throw new Error('Please specify a configName.');\n  }\n  if (configName instanceof RegExp) {\n    return [configName];\n  }\n  if (!Array.isArray(extensions)) {\n    throw new Error('Please provide an array of valid extensions.');\n  }\n  return extensions.map(function(ext) {\n    return configName + ext;\n  });\n};\n","var rechoir = require('rechoir');\n\nmodule.exports = function(eventEmitter, extensions, configPath, cwd) {\n  extensions = extensions || {};\n\n  if (typeof configPath !== 'string') {\n    return;\n  }\n\n  var autoloads = rechoir.prepare(extensions, configPath, cwd, true);\n  if (autoloads instanceof Error) { // Only errors\n    autoloads.failures.forEach(function(failed) {\n      eventEmitter.emit('requireFail', failed.moduleName, failed.error);\n    });\n    return;\n  }\n\n  if (!Array.isArray(autoloads)) { // Already required or no config.\n    return;\n  }\n\n  var succeeded = autoloads[autoloads.length - 1];\n  eventEmitter.emit('require', succeeded.moduleName, succeeded.module);\n};\n","function arrayOrFunction(arrayOrFunc, env) {\n  if (typeof arrayOrFunc === 'function') {\n    return arrayOrFunc.call(this, env);\n  }\n  if (Array.isArray(arrayOrFunc)) {\n    return arrayOrFunc;\n  }\n  if (typeof arrayOrFunc === 'string') {\n    return [arrayOrFunc];\n  }\n  return [];\n}\n\nfunction fromReorderedArgv(reorderedArgv) {\n  var nodeFlags = [];\n  for (var i = 1, n = reorderedArgv.length; i < n; i++) {\n    var arg = reorderedArgv[i];\n    if (!/^-/.test(arg) || arg === '--') {\n      break;\n    }\n    nodeFlags.push(arg);\n  }\n  return nodeFlags;\n}\n\nmodule.exports = {\n  arrayOrFunction: arrayOrFunction,\n  fromReorderedArgv: fromReorderedArgv,\n};\n\n"]}